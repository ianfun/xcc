// C types -- generated by gen.py
constexpr uint8_t
  TYPRIM = 0,TYPOINTER = 1,TYSTRUCT = 2,TYUNION = 3,TYENUM = 4,TYBITFIELD = 5,TYARRAY = 6,TYFUNCTION = 7,TYINCOMPLETE = 8,TYINVALID=0;
struct OpaqueCType {
auto isSigned(CType ty) {
    // `_Bool` is not signed
    return tags & (TYINT8 | TYINT16 | TYINT16 | TYINT32 | TYINT64 | TYINT128);
}
bool isSigned() const {
    return k == TYPRIM && (tags & (
            TYINT8 | TYINT16 | TYINT32 | TYINT64 | 
            TYUINT8 | TYUINT16 | TYUINT32 | TYUINT64 | 
            TYUINT128 | TYBOOL
        ));
}
bool isFloating() const {
	return tags & floatings;
}
bool isScalar() const {
    return k == TYPOINTER ||
    (k == TYPRIM && !(tags & TYVOID));
}
void noralize() {
    constexpr type_tag_t mask = TYTYPEDEF | TYEXTERN | TYSTATIC | TYTHREAD_LOCAL | TYREGISTER;
    switch (k){
    case TYFUNCTION:
    {
        type_tag_t h = ret->tags & mask;
        ret->tags &=  ~mask;
        tags |= h;
        break;
    }
    case TYARRAY:
    {
        type_tag_t h = arrtype->tags & mask;
        arrtype->tags &= ~mask;
        tags |= h;
        break;
    }
    case TYPOINTER:
    {
        type_tag_t h = p->tags & mask;
        p->tags &= ~mask;
        tags |= h;
        break;
    }
    default: break;
    }
}
unsigned getBitWidth() const {
	if (tags & TYINT8)
	    return 8;
	if (tags & TYUINT8)
	    return 8;
	if (tags & TYINT16)
	    return 16;
	if (tags & TYUINT16)
	    return 16;
	if (tags & TYINT32)
	    return 32;
	if (tags & TYUINT32)
	    return 32;
	if (tags & TYINT64)
	    return 64;
	if (tags & TYUINT64)
	    return 64;
	if (tags & TYINT128)
	    return 128;
	if (tags & TYUINT128)
	    return 128;
	if (tags & TYDOUBLE)
	    return 64;
	if (tags & TYFLOAT)
	    return 32;
	if (tags & TYF80)
		return 80;
	if (tags & (TYF128 | TYPPC_128))
		return 128;
	if (tags & TYHALF)
		return 16;
	llvm_unreachable("getting bitWidth in no floating type or integer type");
}
// tags is the first member in structure
type_tag_t tags: 34;
unsigned k: 4;
// https://llvm.org/doxygen/structllvm_1_1Align.html
unsigned align: 8; // align in LogValue
union {
  struct {
      CType p;
    };
  struct {
      size_t sidx;
      IdentRef sname;
      xvector<Declator> selems;
    };
  struct {
      size_t uidx;
      IdentRef uname;
      xvector<Declator> uelems;
    };
  struct {
      size_t eidx;
      IdentRef ename;
      xvector<EnumPair> eelems;
    };
  struct {
      CType bittype;
      unsigned bitsize;
    };
  struct {
      Expr vla;
      CType arrtype;
      bool hassize;
      unsigned arrsize;
    };
  struct {
      CType ret;
      xvector<Param> params;
      bool isVarArg;
    };
  struct {
      uint8_t tag;
      IdentRef name;
      size_t iidx;
    };
  };
};
struct PrimType {
  type_tag_t tags: 34;
  unsigned k: 4 =TYPRIM;
  unsigned align: 8;
 /* empty! */ 
};
struct PointerType {
  type_tag_t tags: 34;
  unsigned k: 4 =TYPOINTER;
  unsigned align: 8;
  struct {
    CType p;
  };
};
struct StructType {
  type_tag_t tags: 34;
  unsigned k: 4 =TYSTRUCT;
  unsigned align: 8;
  struct {
    size_t sidx;
    IdentRef sname;
    xvector<Declator> selems;
  };
};
struct UnionType {
  type_tag_t tags: 34;
  unsigned k: 4 =TYUNION;
  unsigned align: 8;
  struct {
    size_t uidx;
    IdentRef uname;
    xvector<Declator> uelems;
  };
};
struct EnumType {
  type_tag_t tags: 34;
  unsigned k: 4 =TYENUM;
  unsigned align: 8;
  struct {
    size_t eidx;
    IdentRef ename;
    xvector<EnumPair> eelems;
  };
};
struct BitfieldType {
  type_tag_t tags: 34;
  unsigned k: 4 =TYBITFIELD;
  unsigned align: 8;
  struct {
    CType bittype;
    unsigned bitsize;
  };
};
struct ArrayType {
  type_tag_t tags: 34;
  unsigned k: 4 =TYARRAY;
  unsigned align: 8;
  struct {
    Expr vla;
    CType arrtype;
    bool hassize;
    unsigned arrsize;
  };
};
struct FunctionType {
  type_tag_t tags: 34;
  unsigned k: 4 =TYFUNCTION;
  unsigned align: 8;
  struct {
    CType ret;
    xvector<Param> params;
    bool isVarArg;
  };
};
struct IncompleteType {
  type_tag_t tags: 34;
  unsigned k: 4 =TYINCOMPLETE;
  unsigned align: 8;
  struct {
    uint8_t tag;
    IdentRef name;
    size_t iidx;
  };
};
static size_t ctype_size_map[] = {
    sizeof(PrimType),
    sizeof(PointerType),
    sizeof(StructType),
    sizeof(UnionType),
    sizeof(EnumType),
    sizeof(BitfieldType),
    sizeof(ArrayType),
    sizeof(FunctionType),
    sizeof(IncompleteType)
};
static constexpr size_t ctype_max_size = std::max({sizeof(PrimType), sizeof(PointerType), sizeof(StructType), sizeof(UnionType), sizeof(EnumType), sizeof(BitfieldType), sizeof(ArrayType), sizeof(FunctionType), sizeof(IncompleteType)});
