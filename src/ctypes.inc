// C types -- generated by gen.py
enum CTypeKind: uint8_t {
  TYPRIM,
  TYPOINTER,
  TYSTRUCT,
  TYUNION,
  TYENUM,
  TYBITFIELD,
  TYARRAY,
  TYFUNCTION,
  TYINCOMPLETE
};
struct OpaqueCType {
	auto isSigned(CType ty) {
	    // `_Bool` is not signed
	    return tags & (TYINT8 | TYINT16 | TYINT16 | TYINT32 | TYINT64 | TYINT128);
	}
	bool isSigned() const {
	    return k == TYPRIM && (tags & (
	            TYINT8 | TYINT16 | TYINT32 | TYINT64 | 
	            TYUINT8 | TYUINT16 | TYUINT32 | TYUINT64 | 
	            TYUINT128 | TYBOOL
	        ));
	}
	bool isScalar() const {
	    return k == TYPOINTER ||
	    (k == TYPRIM && !(tags & TYVOID));
	}
unsigned getBitWidth() const {
    if (tags & TYINT8)
        return 8;
    if (tags & TYUINT8)
        return 8;
    if (tags & TYINT16)
        return 16;
    if (tags & TYUINT16)
        return 16;
    if (tags & TYINT32)
        return 32;
    if (tags & TYUINT32)
        return 32;
    if (tags & TYINT64)
        return 64;
    if (tags & TYUINT64)
        return 64;
    if (tags & TYINT128)
        return 128;
    if (tags & TYUINT128)
        return 128;
    if (tags & TYDOUBLE)
        return 64;
    if (tags & TYFLOAT)
        return 32;
    llvm_unreachable("getting bitWidth in no floating type or integer type");
}
  CTypeKind k;
  uint32_t align, tags;
  union {
    struct {
      CType p;
    };
    struct {
      IdentRef sname;
      xvector<NameTypePair> selems;
    };
    struct {
      IdentRef uname;
      xvector<NameTypePair> uelems;
    };
    struct {
      IdentRef ename;
      xvector<EnumPair> eelems;
    };
    struct {
      CType bittype;
      unsigned bitsize;
    };
    struct {
      Expr vla;
      CType arrtype;
      bool hassize;
      unsigned arrsize;
    };
    struct {
      CType ret;
      xvector<NameTypePair> params;
      bool isVarArg;
    };
    struct {
      enum CTypeKind tag;
      IdentRef name;;
    };
  };
};
struct PrimType {
  enum CTypeKind k=TYPRIM;
  uint32_t align, tags;
 /* empty! */ 
};struct PointerType {
  enum CTypeKind k=TYPOINTER;
  uint32_t align, tags;
struct {
  
    CType p;

  };};
struct StructType {
  enum CTypeKind k=TYSTRUCT;
  uint32_t align, tags;
struct {
  
    IdentRef sname;
    xvector<NameTypePair> selems;

  };};
struct UnionType {
  enum CTypeKind k=TYUNION;
  uint32_t align, tags;
struct {
  
    IdentRef uname;
    xvector<NameTypePair> uelems;

  };};
struct EnumType {
  enum CTypeKind k=TYENUM;
  uint32_t align, tags;
struct {
  
    IdentRef ename;
    xvector<EnumPair> eelems;

  };};
struct BitfieldType {
  enum CTypeKind k=TYBITFIELD;
  uint32_t align, tags;
struct {
  
    CType bittype;
    unsigned bitsize;

  };};
struct ArrayType {
  enum CTypeKind k=TYARRAY;
  uint32_t align, tags;
struct {
  
    Expr vla;
    CType arrtype;
    bool hassize;
    unsigned arrsize;

  };};
struct FunctionType {
  enum CTypeKind k=TYFUNCTION;
  uint32_t align, tags;
struct {
  
    CType ret;
    xvector<NameTypePair> params;
    bool isVarArg;

  };};
struct IncompleteType {
  enum CTypeKind k=TYINCOMPLETE;
  uint32_t align, tags;
struct {
  
    enum CTypeKind tag;
    IdentRef name;;

  };};
static size_t ctype_size_map[] = {
    sizeof(PrimType),
    sizeof(PointerType),
    sizeof(StructType),
    sizeof(UnionType),
    sizeof(EnumType),
    sizeof(BitfieldType),
    sizeof(ArrayType),
    sizeof(FunctionType),
    sizeof(IncompleteType)
};
static constexpr size_t ctype_max_size = std::max({sizeof(PrimType), sizeof(PointerType), sizeof(StructType), sizeof(UnionType), sizeof(EnumType), sizeof(BitfieldType), sizeof(ArrayType), sizeof(FunctionType), sizeof(IncompleteType)});
