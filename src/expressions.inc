// C expressions -- generated by gen.py
enum ExprKind: uint8_t {
    EConstant,
    EBin,
    EUnary,
    EString,
    EConstantArraySubstript,
    EInitList,
    EVoid,
    EVar,
    ECondition,
    ECast,
    ECall,
    ESubscript,
    EMemberAccess,
    EArrToAddress,
    EPostFix,
    ESizeof,
    EBlockAddress,
    EBuiltinCall
};
struct OpaqueExpr {
OpaqueExpr()=delete;
~OpaqueExpr()=delete;
bool isSimple() const {
  switch (k) {
    case EVar:
    case EString:
    case EConstantArraySubstript:
    case EConstant:
      return true;
    default:
      return false;
  }
}
const location_t *getParenLLoc() const;
const location_t *getParenRLoc() const;
location_t *getParenLLoc();
location_t *getParenRLoc();
location_t getBeginLoc() const ;
location_t getEndLoc() const;
SourceRange getSourceRange() const {return SourceRange(getBeginLoc(), getEndLoc());}
ExprKind k;
CType ty;
union alignas(void*) {
    struct alignas(void*) {
      llvm::Constant* C;
        location_t constantLoc;
        location_t constantEndLoc;
    };
    struct alignas(void*) {
      Expr lhs;
        enum BinOp bop;
        Expr rhs;
    };
    struct alignas(void*) {
      Expr uoperand;
        enum UnaryOp uop;
        location_t opLoc;
    };
    struct alignas(void*) {
      llvm::Constant *string;
        location_t stringLoc;
        location_t stringEndLoc;
    };
    struct alignas(void*) {
      llvm::Constant *array;
        uint64_t cidx;
        location_t casLoc;
        location_t casEndLoc;
    };
    struct alignas(void*) {
      location_t initStartLoc;
        location_t initEndLoc;
        xvector<Initializer> inits;
    };
    struct alignas(void*) {
      Expr voidexpr;
        location_t voidStartLoc;
    };
    struct alignas(void*) {
      unsigned sval;
        IdentRef varName;
        location_t varLoc;
    };
    struct alignas(void*) {
      Expr cond, cleft, cright;
    };
    struct alignas(void*) {
      enum CastOp castop;
        Expr castval;
    };
    struct alignas(void*) {
      Expr callfunc;
        xvector<Expr> callargs;
        location_t callEnd;
    };
    struct alignas(void*) {
      Expr left, right;
    };
    struct alignas(void*) {
      Expr obj;
        xvector<unsigned> idxs;
        location_t memberEndLoc;
    };
    struct alignas(void*) {
      Expr arr3;
    };
    struct alignas(void*) {
      enum PostFixOp pop;
        Expr poperand;
        location_t postFixEndLoc;
    };
    struct alignas(void*) {
      CType theType;
        location_t sizeof_loc_begin;
        location_t sizeof_loc_end;
    };
    struct alignas(void*) {
      label_t addr;
        location_t block_loc_begin;
        IdentRef labelName;
    };
    struct alignas(void*) {
      IdentRef builtin_func_name;
        llvm::Intrinsic::ID ID;
        location_t builtin_call_start_loc;
        xvector<Expr> buitin_call_args;
        llvm::FunctionType *builtin_func_type;
    };
};
};
struct ConstantExpr {
    enum ExprKind k=EConstant;
    CType ty;
    struct alignas(void*) {
          llvm::Constant* C;
        location_t constantLoc;
        location_t constantEndLoc;
  };
};
struct BinExpr {
    enum ExprKind k=EBin;
    CType ty;
    struct alignas(void*) {
          Expr lhs;
        enum BinOp bop;
        Expr rhs;
  };
};
struct UnaryExpr {
    enum ExprKind k=EUnary;
    CType ty;
    struct alignas(void*) {
          Expr uoperand;
        enum UnaryOp uop;
        location_t opLoc;
  };
};
struct StringExpr {
    enum ExprKind k=EString;
    CType ty;
    struct alignas(void*) {
          llvm::Constant *string;
        location_t stringLoc;
        location_t stringEndLoc;
  };
};
struct ConstantArraySubstriptExpr {
    enum ExprKind k=EConstantArraySubstript;
    CType ty;
    struct alignas(void*) {
          llvm::Constant *array;
        uint64_t cidx;
        location_t casLoc;
        location_t casEndLoc;
  };
};
struct InitListExpr {
    enum ExprKind k=EInitList;
    CType ty;
    struct alignas(void*) {
          location_t initStartLoc;
        location_t initEndLoc;
        xvector<Initializer> inits;
  };
};
struct VoidExpr {
    enum ExprKind k=EVoid;
    CType ty;
    struct alignas(void*) {
          Expr voidexpr;
        location_t voidStartLoc;
  };
};
struct VarExpr {
    enum ExprKind k=EVar;
    CType ty;
    struct alignas(void*) {
          unsigned sval;
        IdentRef varName;
        location_t varLoc;
  };
};
struct ConditionExpr {
    enum ExprKind k=ECondition;
    CType ty;
    struct alignas(void*) {
          Expr cond, cleft, cright;
  };
};
struct CastExpr {
    enum ExprKind k=ECast;
    CType ty;
    struct alignas(void*) {
          enum CastOp castop;
        Expr castval;
  };
};
struct CallExpr {
    enum ExprKind k=ECall;
    CType ty;
    struct alignas(void*) {
          Expr callfunc;
        xvector<Expr> callargs;
        location_t callEnd;
  };
};
struct SubscriptExpr {
    enum ExprKind k=ESubscript;
    CType ty;
    struct alignas(void*) {
          Expr left, right;
  };
};
struct MemberAccessExpr {
    enum ExprKind k=EMemberAccess;
    CType ty;
    struct alignas(void*) {
          Expr obj;
        xvector<unsigned> idxs;
        location_t memberEndLoc;
  };
};
struct ArrToAddressExpr {
    enum ExprKind k=EArrToAddress;
    CType ty;
    struct alignas(void*) {
          Expr arr3;
  };
};
struct PostFixExpr {
    enum ExprKind k=EPostFix;
    CType ty;
    struct alignas(void*) {
          enum PostFixOp pop;
        Expr poperand;
        location_t postFixEndLoc;
  };
};
struct SizeofExpr {
    enum ExprKind k=ESizeof;
    CType ty;
    struct alignas(void*) {
          CType theType;
        location_t sizeof_loc_begin;
        location_t sizeof_loc_end;
  };
};
struct BlockAddressExpr {
    enum ExprKind k=EBlockAddress;
    CType ty;
    struct alignas(void*) {
          label_t addr;
        location_t block_loc_begin;
        IdentRef labelName;
  };
};
struct BuiltinCallExpr {
    enum ExprKind k=EBuiltinCall;
    CType ty;
    struct alignas(void*) {
          IdentRef builtin_func_name;
        llvm::Intrinsic::ID ID;
        location_t builtin_call_start_loc;
        xvector<Expr> buitin_call_args;
        llvm::FunctionType *builtin_func_type;
  };
};
static uint8_t expr_size_map[] = {
    sizeof(ConstantExpr),
    sizeof(BinExpr),
    sizeof(UnaryExpr),
    sizeof(StringExpr),
    sizeof(ConstantArraySubstriptExpr),
    sizeof(InitListExpr),
    sizeof(VoidExpr),
    sizeof(VarExpr),
    sizeof(ConditionExpr),
    sizeof(CastExpr),
    sizeof(CallExpr),
    sizeof(SubscriptExpr),
    sizeof(MemberAccessExpr),
    sizeof(ArrToAddressExpr),
    sizeof(PostFixExpr),
    sizeof(SizeofExpr),
    sizeof(BlockAddressExpr),
    sizeof(BuiltinCallExpr)
};
static constexpr size_t expr_max_size = std::max({sizeof(ConstantExpr), sizeof(BinExpr), sizeof(UnaryExpr), sizeof(StringExpr), sizeof(ConstantArraySubstriptExpr), sizeof(InitListExpr), sizeof(VoidExpr), sizeof(VarExpr), sizeof(ConditionExpr), sizeof(CastExpr), sizeof(CallExpr), sizeof(SubscriptExpr), sizeof(MemberAccessExpr), sizeof(ArrToAddressExpr), sizeof(PostFixExpr), sizeof(SizeofExpr), sizeof(BlockAddressExpr), sizeof(BuiltinCallExpr)});
