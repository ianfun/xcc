#! /usr/bin/env python3

# the super C++ code generator!

import sys

keywords = [
	"extern",
	"short",	
	"register",
	"_Thread_local",
	"static",
	"auto",
	"inline",
	"typedef",
	"_Noreturn",


	"_Decimal32",
	"_Decimal128",
	"_Decimal64",
	"_Imaginary",
	"_Complex",
	"_Atomic",
	"_Bool",
	
	"union",
	"struct",
	"enum",
	"unsigned",
	"signed",
	"void",
	"int",
	"char",
	"long",
	"float",
	"double",

	"_Alignas",
	"const",
	"restrict",
	"volatile",

	"asm",
	"__asm__",
	"return",
	"for",
	"case",
	"switch",
	"goto",
	"default",
	"if",
	"else",
	"do",
	"sizeof",
	"continue",
	"break",
	"while",
	"_Alignof",
	"_Static_assert",
	"_Generic"
]
stmts = {
	"SHead": [],
	"SCompound": ["Stmt inner"],
	"SLabel": ["label_t label", "IdentRef labelName"],
	"SGoto": ["label_t location"],
	"SCondJump": ["Expr test", "label_t T", "label_t F"],
	"SDeclOnly": ["CType decl"],
	"SReturn": ["Expr ret"],
	"SExpr": ["Expr exprbody"],
	"SAsm": ["xstring asms"],
	"SVarDecl": ["xvector<VarDecl> vars"],
	"SFunction": ["IdentRef funcname", "CType functy", "Stmt funcbody", "unsigned numLabels"],
}
exprs = {
	"EBin": ["Expr lhs", "enum BinOp bop", "Expr rhs"],
	"EUnary": ["Expr uoperand", "enum UnaryOp uop"],
	"EIntLit": ["APInt ival"],
	"EFloatLit": ["APFloat fval"],
	"EVoid": ["Expr voidexpr"],
	"EVar": ["IdentRef sval"],
	"ECondition": ["Expr cond, cleft, cright"],
	"ECast": ["enum CastOp castop", "Expr castval"],
	"ECall": ["Expr callfunc", "xvector<Expr> callargs"],
	"ESubscript": ["Expr left, right"],
	"EDefault": [],
	"EArray": ["xvector<Expr> arr"],
	"EStruct": ["xvector<Expr> arr2"],
	"EString": ["xstring str", "bool is_constant"],
	"EUndef": [],
	"EMemberAccess": ["Expr obj", "uint32_t idx"],
	"EArrToAddress": ["Expr arr3"],
	"EPostFix": ["enum PostFixOp pop", "Expr poperand"]
}
ctypes = {
	"TYPRIM": [],
	"TYPOINTER": ["CType p"],
	"TYSTRUCT": ["IdentRef sname", "xvector<NameTypePair> selems"],
	"TYUNION": ["IdentRef uname", "xvector<NameTypePair> uelems"],
	"TYENUM": ["IdentRef ename", "xvector<EnumPair> eelems"],
	"TYBITFIELD": ["CType bittype", "unsigned bitsize"],
	"TYARRAY": ["Expr vla", "CType arrtype", "bool hassize", "unsigned arrsize"],
	"TYFUNCTION": ["CType ret", "xvector<NameTypePair> params", "bool isVarArg"],
	"TYINCOMPLETE": ["enum CTypeKind tag", "IdentRef name;"]
}

def verbose(msg):
	sys.stdout.write(msg)

def switchGen(d, f, de):
	class Tree:
		def __init__(self):
			self.childs = {}

	root = Tree()
	for (h, v) in d.items():
		ptr = root
		for c in h:
			if c not in ptr.childs:
				ptr.childs[c] = Tree()
			ptr = ptr.childs[c]
		ptr.childs['\0'] = v
	def printer(n, i):
		tab = '\t' * i
		f.write(tab + "switch(*s++){\n")
		tab2 = '\t' + tab
		for k, v in n.childs.items():
			if isinstance(v, Tree):
				f.write(tab2 + "case '" + k + "':\n")
				printer(v, i + 1)
			else:
				f.write(tab2 + "case '\\0': return " + v + ";\n")
		f.write(tab2 + "default: return " + de + ";\n" + tab + "}\n")
	printer(root, 1)

def gen_keywords():
	verbose("generating keywords...")
	f = open("keywords.inc", "w")
	f.write("Token getKeyword(const char *s){\n")
	d = dict()
	for i in keywords:
		d[i] = 'K' + i
	switchGen(d, f, "TNul")
	f.write('}\n')
	f.close()
	verbose("done.\n")

def gen_PPDirective():
	verbose("generating C proprocessor directives...")
	f = open("directives.inc", "w")
	f.write("enum PPDirective {\n  PPNotADirective,\n  ")
	directives = ("if", "ifdef", "ifndef", "else", "elseif", "endif", "undef", "pragma", "line", "include", "warning", "error")
	f.write(',\n  '.join(("PP" + a + " /*#%s*/" % a) for a in directives))
	f.write("\n};\n")
	f.write("enum PPDirective getDirective(const char *s){\n")
	d = dict()
	for i in directives:
		d[i] = "PP" + i
	switchGen(d, f, "PPNotADirective")
	f.write('}\n')
	f.close()
	verbose("done.\n")

def gen_tokens():
	def cstr(s):
		return s.replace('\\', '\\\\').replace('"', '\\"')
	verbose("generating tokens...")
	f = open("tokens.inc", "w")
	f.write("// C tokens -- generated by gen.py\n")
	ops = []
	ppkeywords = []
	def T(name, show, s = None):
		ops.append((name, show, s))
	def P(name, show, b = False):
		ppkeywords.append((name, show, b))
	T("TNul", "(null)")
	T("TNewLine", "(new-line)")
	T("TSpace", "(space)")
	T("TNot", "!")
	T("TDoubleQ", "\"")
	T("TBash", "~")
	T("TDolor", "$")
	T("TPercent",  "%")
	T("TBitAnd",  "&")
	T("TSignleQ",  "'")
	T("TLbracket",  "(")
	T("TRbracket",  ")")
	T("TMul",  "*")
	T("TAdd",  "+")
	T("TComma",  ",")
	T("TDash",  "-")
	T("TDot",  ".")
	T("TSlash",  "/")
	T("TColon",  ":")
	T("TSemicolon",  ";")
	T("TLt",  "<")
	T("TAssign",  "=")
	T("TGt",  ">")
	T("TQuestionMark",  "?")
	T("TMouse",  "@")
	T("TLSquareBrackets",  "[")
	T("TBackslash",  "\\")
	T("TRSquareBrackets",  "]")
	T("TXor",  "^")
	T("TUnderscore",  "_")
	T("TGraveAccent",  "`")
	T("TLcurlyBracket",  "{")
	T("TBitOr",  "|")
	T("TRcurlyBracket",  "}")
	T("TBitNot",  "~")
	T("TAddAdd", "++")
	T("TSubSub", "--")
	T("TArrow", "->")
	T("Tshl", "<<")
	T("Tshr", ">>")
	T("TGe", ">=")
	T("TLe", "<=")
	T("TNe", "!=")
	T("TEq", "==")
	T("TLogicalOr", "||")
	T("TLogicalAnd", "&&")
	T("TAsignAdd", "+=")
	T("TAsignSub", "-=")
	T("TAsignMul", "*=")
	T("TAsignDiv", "/=")
	T("TAsignRem", "%=")
	T("TAsignShl", "<<=")
	T("TAsignShr",">>=")
	T("TAsignBitAnd", "&=")
	T("TAsignBitOr", "|=")
	T("TAsignBitXor", "^=")
	T("TEllipsis2", "..")
	T("TEllipsis","...")
	T("TCharLit", "<char>")
	T("TStringLit", "<string>")
	T("PPlaceholder", "<placeholder>")
	T("PPSharp", "#")
	T("PPNumber", "<pp-number>")
	T("PPSharpSharp", "##")
	T("PPMacroPop", "<PPMacroPop>")
	T("TEOF", "<EOF>")
	
	P("TIdentifier", "<TIdentifier>") # name(identifier), after macro processing
	P("PPIdent", "<PPIdent>") # identifier, may be a macro
	P("PP__func__", "__func__", True)
	P("PP_main", "main", True)
	P("PP__VA_ARGS__", "__VA_ARGS__", True)
	# built-in macros
	P("PP__LINE__", "__LINE__", True)
	P("PP__FILE__", "__FILE__", True)
	P("PP__DATE__", "__DATE__", True)
	P("PP__TIME__", "__TIME__", True)
	P("PP__COUNTER__", "__COUNTER__", True)
	P("PP_defined", "defined", True)
	P("PP_Pragma", "_Pragma", True)
	# preprocessor directives
	P("PPifdef", "ifdef", True)
	P("PPifndef", "ifndef", True)
	P("PPelif", "elif", True)
	P("PPendif", "endif", True)
	P("PPdefine", "define", True)
	P("PPundef", "undef", True)
	P("PPline", "line", True)
	P("PPinclude", "include", True)
	P("PPwarning", "warning", True)
	P("PPerror", "error", True)
	P("PPpragma", "pragma", True)

	f.write("enum Token: unsigned char {\n  ")
	f.write(",\n  ".join(x[0] for x in ops) + ",\n  ")
	f.write(",\n  ".join(('K' + i for i in keywords)) + ",\n  ")
	f.write(",\n  ".join((i[0] for i in ppkeywords)) + "\n};\n")
	f.write("static const char *show(Token o){\n  switch(o) {\n")
	f.write('\n'.join(("    case K%s: return \"%s\";" % (k, k)) for k in keywords) + '\n')
	f.write('\n'.join(("    case %s: return \"%s\";" % (x[0], x[1])) for x in ppkeywords) + '\n')
	f.write('\n'.join(("    case %s: return \"%s\";" % (x[0], cstr(x[1]))) for x in ops))
	f.write("\n    default: return \"(unknown token)\";\n  }\n}\n")
	f.close()
	f = open("IdentifierTableInit.inc", "w")
	f.write(',\n'.join(
		('{"%s", %s}' % (i, 'K' + i)) for i in keywords)
	)
	f.write(',\n')
	f.write(',\n'.join(
		('{"%s", %s}' % (i[1], i[0])) for i in filter(lambda x: x[2], ppkeywords))
	)
	f.write('\n')
	f.close()
	verbose("done.\n")

def gen_type_tags():
	verbose("generating type tags...")
	f = open("types.inc", "w")
	f.write("// optional type tags -- generated by gen.py\n")
	tags = [
		"TYCONST",
		"TYRESTRICT",
		"TYVOLATILE",
		"TYATOMIC",
		"TYINLINE",
		"TYSTATIC",
		"TYNORETURN",
		"TYEXTERN",
		"TYREGISTER",
		"TYTHREAD_LOCAL",
		"TYTYPEDEF",
		"TYLVALUE",
		"TYPARAM",
		"TYVOID",
		"TYBOOL",
		"TYCOMPLEX",
		"TYINT8",
		"TYINT16",
		"TYINT32",
		"TYINT64",
		"TYINT128",
		"TYUINT8",
		"TYUINT16",
		"TYUINT32",
		"TYUINT64",
		"TYUINT128",
		"TYFLOAT",
		"TYDOUBLE",
		"TYF128"
	]
	i = 0
	f.write("constexpr uint32_t\n  TYINVALID=0,\n")
	for t in tags:
		x = 1 << i
		f.write("  %s=0x%x,\n" % (t, x))
		i += 1
	f.write("""\
// type alias
  TYCHAR = TYINT8,
  TYSHORT = TYINT16,
  TYINT = TYINT32,
#if CC_LONG64
  TYLONG=TYINT64,
  TYULONG=TYUINT64,
#else
  TYLONG=TYINT32,
  TYULONG=TYINT32,
#endif
  TYLONGLONG = TYINT64,
  TYUCHAR = TYUINT8,
  TYUSHORT = TYUINT16,
  TYUINT = TYUINT32,
  TYULONGLONG = TYUINT64,
  TYLONGDOUBLE = TYDOUBLE,
  ty_prim = 
    TYINT8 | TYINT16 | TYINT32 | TYINT64 | 
    TYUINT8 | TYUINT16 | TYUINT32 | TYUINT64 |
    TYFLOAT | TYDOUBLE | TYBOOL,
  ty_unsigned = TYUINT8 | TYUINT16 | TYUINT32 | TYUINT64;\n""")
	f.close()
	verbose("done.\n")

def sizeof(l):
	for i in l:
		yield "sizeof(%s)" % i

def gen_expr():
	verbose("generating expressions...")
	f = open("expressions.inc", "w")
	f.write("// C expressions -- generated by gen.py\n")
	f.write("enum ExprKind: uint8_t {\n  " + ',\n  '.join(exprs.keys()) + '\n};\n')
	f.write("""\
struct OpaqueExpr {
  OpaqueExpr()=delete;
  ~OpaqueExpr()=delete;
  ExprKind k;
  Location loc;
  CType ty;\n
  union {
""")
	for decls in exprs.values():
		if decls:
			f.write("    struct {\n      " + ';\n      '.join(decls) + ';\n    };\n')
	f.write("""};\n};\n""")
	l = []
	for name, decls in exprs.items():		
		realname = name[1::] + "Expr"
		l.append(realname)
		if decls:
			f.write("struct " + realname + " {\n  enum ExprKind k=" + name + ";\n  Location loc;\n  CType ty;\nstruct {\n  ")
			f.write('    ' + ';\n    '.join(decls) + ';\n')
			f.write("\n  };};\n")
		else:
			f.write("struct " + realname + " {\n  enum ExprKind k=" + name + ";\n  Location loc;\n  CType ty;\n /* empty! */ \n};")
	f.write("static uint8_t expr_size_map[] = {\n    " + 
		',\n    '.join(sizeof(l)) + 
		"\n};\n")
	f.write("static constexpr size_t expr_max_size = std::max({" + ', '.join(sizeof(l)) + "});\n")
	f.close()
	verbose("done.\n")

def gen_stmt():
	verbose("generating statements...")
	f = open("statements.inc", "w")
	f.write("// C statements and declarations -- generated by gen.py\n")
	f.write("enum StmtKind: uint8_t {\n  " + ',\n  '.join(stmts.keys()) + '\n};\n')
	f.write("""\
struct NullStmt {
  enum StmtKind k;
  Location loc;
  Stmt next;
};
struct OpaqueStmt {
  StmtKind k;
  Location loc;
  Stmt next;
  union {
""")
	for decls in stmts.values():
		if decls:
			f.write("  struct {\n      " + ';\n    '.join(decls) + ';\n  };\n')
	f.write("""};};\n""")
	l = []
	for name, decls in stmts.items():
		realname = name[1::] + "Stmt"
		l.append(realname)
		if decls:
			f.write("struct " + realname + " {\n  enum StmtKind k=" + name + ";\n  Location loc;\n  Stmt next;\nstruct {\n  \n")
			f.write('    ' + ';\n    '.join(decls) + ';\n')
			f.write("\n  };};\n")
		else:
			f.write("struct " + realname + " {\n  enum StmtKind k=" + name + ";\n  Location loc;\n  Stmt next;\n /* empty! */ \n};")

	f.write("static uint8_t stmt_size_map[] = {\n    " + 
		',\n    '.join(sizeof(l)) + 
		"\n};\n")
	f.write("static constexpr size_t stmt_max_size = std::max({" + ', '.join(sizeof(l)) + "});\n")

	f.close()
	verbose("done.\n")

def gen_ctypes():
	verbose("generating C types...")
	f = open("ctypes.inc", "w")
	f.write("// C types -- generated by gen.py\n")
	f.write("enum CTypeKind: uint8_t {\n  " + ',\n  '.join(ctypes.keys()) + '\n};\n')
	f.write("""\
struct OpaqueCType {
	auto isSigned(CType ty) {
	    // `_Bool` is not signed
	    return tags & (TYINT8 | TYINT16 | TYINT16 | TYINT32 | TYINT64 | TYINT128);
	}
	bool isSigned() const {
	    return k == TYPRIM && (tags & (
	            TYINT8 | TYINT16 | TYINT32 | TYINT64 | 
	            TYUINT8 | TYUINT16 | TYUINT32 | TYUINT64 | 
	            TYUINT128 | TYBOOL
	        ));
	}
	bool isScalar() const {
	    return k == TYPOINTER ||
	    (k == TYPRIM && !(tags & TYVOID));
	}
unsigned getBitWidth() const {
    if (tags & TYINT8)
        return 8;
    if (tags & TYUINT8)
        return 8;
    if (tags & TYINT16)
        return 16;
    if (tags & TYUINT16)
        return 16;
    if (tags & TYINT32)
        return 32;
    if (tags & TYUINT32)
        return 32;
    if (tags & TYINT64)
        return 64;
    if (tags & TYUINT64)
        return 64;
    if (tags & TYINT128)
        return 128;
    if (tags & TYUINT128)
        return 128;
    if (tags & TYDOUBLE)
        return 64;
    if (tags & TYFLOAT)
        return 32;
    llvm_unreachable("getting bitWidth in no floating type or integer type");
}
  CTypeKind k;
  uint32_t align, tags;
  union {
""")
	for decls in ctypes.values():
		if decls:
			f.write("    struct {\n      " + ';\n      '.join(decls) + ';\n    };\n')
	f.write("""  };\n};\n""")
	l = []
	for name, decls in ctypes.items():
		realname = name[2:3] + name[3::].lower() + "Type"
		l.append(realname)
		if decls:
			f.write("struct " + realname + " {\n  enum CTypeKind k=" + name + ";\n  uint32_t align, tags;\nstruct {\n  \n")
			f.write('    ' + ';\n    '.join(decls) + ';\n')
			f.write("\n  };};\n")
		else:
			f.write("struct " + realname + " {\n  enum CTypeKind k=" + name + ";\n  uint32_t align, tags;\n /* empty! */ \n};")
	f.write("static size_t ctype_size_map[] = {\n    " + 
		',\n    '.join(sizeof(l)) + 
		"\n};\n")
	f.write("static constexpr size_t ctype_max_size = std::max({" + ', '.join(sizeof(l)) + "});\n")

	f.close()
	verbose("done.\n")

def main():
	import argparse, sys
	parser = argparse.ArgumentParser(description="the super C++ code generator\nselect targets to generate, or '--all' generate all")
	parser.add_argument("-all", action='store_true', help="generate all targets")
	parser.add_argument("-keywords", action='store_true', help="generate keywords")
	parser.add_argument("-tokens", action='store_true', help="generate tokens")
	parser.add_argument("-type_tags", action='store_true', help="generate type_tags")
	parser.add_argument("-expr", action='store_true', help="generate Expr")
	parser.add_argument("-stmt", action='store_true', help="generate Stmt")
	parser.add_argument("-ctypes", action='store_true', help="generate ctypes")
	parser.add_argument("-directive", action='store_true', help="generate directives")
	if len(sys.argv) == 1:
		parser.print_help()
		parser.error("no targets to generate")
	args = parser.parse_args()
	if args.all:
	  return gen_keywords() or gen_tokens() or gen_type_tags() or gen_expr() or gen_stmt() or gen_ctypes() or gen_PPDirective()
	if args.keywords:
		gen_keywords()
	if args.expr:
		gen_expr()
	if args.stmt:
		gen_stmt()
	if args.ctypes:
		gen_ctypes()
	if args.type_tags:
		gen_type_tags()
	if args.tokens:
		gen_tokens()
	if args.directive:
		gen_PPDirective()

if __name__ == '__main__':
  main()
